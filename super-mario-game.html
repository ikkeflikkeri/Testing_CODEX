<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario Bros - Ultimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 60px rgba(0, 150, 255, 0.6);
        }

        #gameCanvas {
            display: block;
            background: #5c94fc;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #000 0%, #1a0033 50%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.5s;
        }

        #titleScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title {
            font-size: 56px;
            font-weight: bold;
            color: #fff;
            text-shadow:
                4px 4px 0 #ff0000,
                8px 8px 0 #cc0000,
                12px 12px 20px #000;
            margin-bottom: 10px;
            animation: titlePulse 3s infinite;
            letter-spacing: 4px;
        }

        .subtitle {
            font-size: 20px;
            color: #ffd700;
            margin-bottom: 60px;
            text-shadow: 2px 2px 4px #000;
            animation: subtitleFloat 2s ease-in-out infinite;
        }

        .startButton {
            padding: 25px 50px;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(180deg, #ff6b6b 0%, #cc0000 100%);
            border: 5px solid #fff;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow:
                0 8px 0 #8b0000,
                0 15px 30px rgba(0,0,0,0.5);
            transition: all 0.1s;
            font-family: inherit;
            letter-spacing: 2px;
        }

        .startButton:hover {
            background: linear-gradient(180deg, #ff8787 0%, #ff0000 100%);
            transform: translateY(-2px);
            box-shadow:
                0 10px 0 #8b0000,
                0 20px 40px rgba(0,0,0,0.6);
        }

        .startButton:active {
            transform: translateY(6px);
            box-shadow:
                0 2px 0 #8b0000,
                0 5px 15px rgba(0,0,0,0.4);
        }

        .controls {
            margin-top: 40px;
            font-size: 14px;
            color: #aaa;
            text-align: center;
            line-height: 1.8;
        }

        .controls div {
            margin: 5px 0;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes subtitleFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .hud {
            position: absolute;
            top: 15px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 3px 3px 0 #000;
            z-index: 5;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hud-label {
            color: #ffd700;
        }

        .hud-value {
            color: #fff;
            min-width: 60px;
        }

        .message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px 60px;
            border: 5px solid #fff;
            border-radius: 10px;
            text-align: center;
            z-index: 20;
            display: none;
        }

        .message-overlay.show {
            display: block;
            animation: messagePopIn 0.3s ease-out;
        }

        @keyframes messagePopIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .message-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #000;
        }

        .message-text {
            font-size: 18px;
            color: #fff;
            margin-bottom: 15px;
        }

        .victory .message-title { color: #ffd700; }
        .gameover .message-title { color: #ff4444; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="960" height="640"></canvas>

        <div id="titleScreen">
            <div class="title">SUPER MARIO</div>
            <div class="subtitle">★ Ultimate Edition ★</div>
            <button class="startButton" onclick="startGame()">Start Adventure</button>
            <div class="controls">
                <div>← → Arrow Keys: Move</div>
                <div>SPACE: Jump (hold for higher jump)</div>
                <div>SHIFT: Run / Shoot Fireballs</div>
                <div>R: Restart</div>
            </div>
        </div>

        <div class="hud">
            <div class="hud-item">
                <span class="hud-label">SCORE</span>
                <span class="hud-value" id="score">000000</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">COINS</span>
                <span class="hud-value" id="coins">×00</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">WORLD</span>
                <span class="hud-value">1-1</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">TIME</span>
                <span class="hud-value" id="time">400</span>
            </div>
        </div>

        <div id="messageOverlay" class="message-overlay">
            <div class="message-title" id="messageTitle"></div>
            <div class="message-text" id="messageText"></div>
            <div class="message-text" id="messageSubtext"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const GRAVITY = 0.55;
        const FRICTION = 0.88;
        const MAX_WALK_SPEED = 3.2;
        const MAX_RUN_SPEED = 5.8;
        const ACCELERATION = 0.42;
        const RUN_ACCELERATION = 0.65;
        const JUMP_POWER = 13.5;
        const JUMP_POWER_BIG = 14.5;
        const FIREBALL_SPEED = 7;

        // Game State
        const game = {
            state: 'title',
            score: 0,
            coins: 0,
            lives: 3,
            time: 400,
            camera: { x: 0, y: 0, shake: 0 },
            keys: {},
            levelWidth: 8000,
            particles: [],
            floatingTexts: [],
            combo: 0,
            comboTimer: 0
        };

        // Audio System
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            switch(type) {
                case 'jump':
                    osc.frequency.setValueAtTime(500, now);
                    osc.frequency.exponentialRampToValueAtTime(700, now + 0.08);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    osc.start(now);
                    osc.stop(now + 0.08);
                    break;
                case 'coin':
                    osc.frequency.setValueAtTime(1000, now);
                    osc.frequency.setValueAtTime(1200, now + 0.03);
                    osc.frequency.setValueAtTime(1400, now + 0.06);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                    osc.start(now);
                    osc.stop(now + 0.12);
                    break;
                case 'stomp':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'powerup':
                    osc.frequency.setValueAtTime(262, now);
                    osc.frequency.setValueAtTime(294, now + 0.05);
                    osc.frequency.setValueAtTime(330, now + 0.1);
                    osc.frequency.setValueAtTime(392, now + 0.15);
                    osc.frequency.setValueAtTime(440, now + 0.2);
                    osc.frequency.setValueAtTime(523, now + 0.25);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
                    osc.start(now);
                    osc.stop(now + 0.35);
                    break;
                case 'fireball':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
                case 'breakblock':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                case 'death':
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.6);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                    osc.start(now);
                    osc.stop(now + 0.6);
                    break;
                case 'victory':
                    const notes = [523, 587, 659, 784, 880, 1047];
                    notes.forEach((freq, i) => {
                        const o = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        o.connect(g);
                        g.connect(audioCtx.destination);
                        o.frequency.setValueAtTime(freq, now + i * 0.08);
                        g.gain.setValueAtTime(0.15, now + i * 0.08);
                        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.3);
                        o.start(now + i * 0.08);
                        o.stop(now + i * 0.08 + 0.3);
                    });
                    return;
            }
        }

        // Utility Functions
        function addFloatingText(x, y, text, color = '#fff') {
            game.floatingTexts.push({
                x, y, text, color,
                life: 60,
                vy: -1.5
            });
        }

        function addScore(points, x, y) {
            game.score += points;
            addFloatingText(x, y, points.toString(), '#ffd700');
        }

        function createParticles(x, y, count, color, speed = 4) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * speed,
                    vy: (Math.random() - 0.5) * speed - 2,
                    life: 40 + Math.random() * 20,
                    maxLife: 60,
                    color,
                    size: 3 + Math.random() * 3
                });
            }
        }

        function shakeCamera(intensity = 5) {
            game.camera.shake = intensity;
        }

        // Player Class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 28;
                this.height = 32;
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.dir = 1;
                this.state = 'small'; // small, big, fire
                this.invincible = false;
                this.invincibleTimer = 0;
                this.animFrame = 0;
                this.animTimer = 0;
                this.jumping = false;
                this.running = false;
                this.skidding = false;
                this.dead = false;
                this.deathTimer = 0;
                this.shootCooldown = 0;
            }

            update() {
                if (this.dead) {
                    this.deathTimer++;
                    this.vy += GRAVITY * 0.8;
                    this.y += this.vy;
                    if (this.deathTimer > 120) {
                        game.lives--;
                        if (game.lives <= 0) {
                            this.showGameOver();
                        } else {
                            this.respawn();
                        }
                    }
                    return;
                }

                const wasOnGround = this.onGround;
                this.running = game.keys['Shift'];

                // Horizontal movement
                const maxSpeed = this.running ? MAX_RUN_SPEED : MAX_WALK_SPEED;
                const accel = this.running ? RUN_ACCELERATION : ACCELERATION;

                if (game.keys['ArrowLeft']) {
                    if (this.vx > 0.5) {
                        this.skidding = true;
                    }
                    this.vx -= accel;
                    this.dir = -1;
                } else if (game.keys['ArrowRight']) {
                    if (this.vx < -0.5) {
                        this.skidding = true;
                    }
                    this.vx += accel;
                    this.dir = 1;
                } else {
                    this.skidding = false;
                }

                // Apply friction
                this.vx *= FRICTION;
                if (Math.abs(this.vx) < 0.1) {
                    this.vx = 0;
                    this.skidding = false;
                }

                // Limit speed
                if (this.vx > maxSpeed) this.vx = maxSpeed;
                if (this.vx < -maxSpeed) this.vx = -maxSpeed;

                // Jumping
                if (game.keys[' '] && this.onGround && !this.jumping) {
                    const jumpPower = this.state === 'small' ? JUMP_POWER : JUMP_POWER_BIG;
                    this.vy = -jumpPower;
                    this.onGround = false;
                    this.jumping = true;
                    playSound('jump');
                }

                // Variable jump height
                if (!game.keys[' '] && this.vy < -4) {
                    this.vy = -4;
                }

                // Shooting fireballs
                if (this.state === 'fire' && game.keys['Shift'] && this.shootCooldown === 0) {
                    this.shootCooldown = 20;
                    fireballs.push(new Fireball(
                        this.x + (this.dir > 0 ? this.width : 0),
                        this.y + 10,
                        this.dir
                    ));
                    playSound('fireball');
                }

                if (this.shootCooldown > 0) this.shootCooldown--;

                // Apply gravity
                this.vy += GRAVITY;
                if (this.vy > 16) this.vy = 16;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Ground collision
                const groundY = 608 - this.height;
                if (this.y >= groundY) {
                    this.y = groundY;
                    this.vy = 0;
                    this.onGround = true;
                    this.jumping = false;
                }

                // Bounds
                if (this.x < 0) this.x = 0;
                if (this.x > game.levelWidth - this.width) {
                    this.x = game.levelWidth - this.width;
                }

                // Death by falling
                if (this.y > canvas.height + 100) {
                    this.die();
                }

                // Invincibility
                if (this.invincible) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer <= 0) {
                        this.invincible = false;
                    }
                }

                // Animation
                if (Math.abs(this.vx) > 0.5) {
                    this.animTimer++;
                    const speed = this.running ? 4 : 6;
                    if (this.animTimer > speed) {
                        this.animTimer = 0;
                        this.animFrame = (this.animFrame + 1) % 4;
                    }
                } else {
                    this.animFrame = 0;
                    this.animTimer = 0;
                }

                // Camera
                const targetCameraX = this.x - canvas.width / 3;
                game.camera.x += (targetCameraX - game.camera.x) * 0.1;
                if (game.camera.x < 0) game.camera.x = 0;
                if (game.camera.x > game.levelWidth - canvas.width) {
                    game.camera.x = game.levelWidth - canvas.width;
                }

                // Camera shake
                if (game.camera.shake > 0) {
                    game.camera.shake *= 0.9;
                    if (game.camera.shake < 0.1) game.camera.shake = 0;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                // Camera shake
                if (game.camera.shake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * game.camera.shake,
                        (Math.random() - 0.5) * game.camera.shake
                    );
                }

                // Invincibility flicker
                if (this.invincible && Math.floor(this.invincibleTimer / 4) % 2 === 0) {
                    ctx.globalAlpha = 0.4;
                }

                const h = this.state === 'small' ? 32 : 48;
                const w = 28;

                // Death animation
                if (this.dead) {
                    ctx.save();
                    ctx.translate(this.x + w/2, this.y + h/2);
                    ctx.rotate(Math.PI);
                    ctx.translate(-(this.x + w/2), -(this.y + h/2));
                }

                // Skidding particles
                if (this.skidding && this.onGround) {
                    createParticles(this.x + w/2, this.y + h, 1, '#888', 2);
                }

                // Hat
                ctx.fillStyle = this.state === 'fire' ? '#ff4444' : '#e30000';
                ctx.fillRect(this.x + 4, this.y + (this.state === 'small' ? 0 : 0), 20, 10);
                ctx.fillRect(this.x + 2, this.y + (this.state === 'small' ? 2 : 2), 24, 6);

                // Face
                ctx.fillStyle = '#ffb380';
                ctx.fillRect(this.x + 6, this.y + 8 + (this.state === 'small' ? 0 : 4), 16, 14);

                // Eyes
                ctx.fillStyle = '#000';
                const eyeOffset = this.dir > 0 ? 12 : 8;
                ctx.fillRect(this.x + eyeOffset, this.y + 12 + (this.state === 'small' ? 0 : 4), 5, 4);
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + eyeOffset + 1, this.y + 13 + (this.state === 'small' ? 0 : 4), 2, 2);

                // Mustache
                ctx.fillStyle = '#3d2817';
                ctx.fillRect(this.x + 6, this.y + 17 + (this.state === 'small' ? 0 : 4), 16, 4);

                // Shirt
                const shirtColor = this.state === 'fire' ? '#ffffff' : '#e30000';
                ctx.fillStyle = shirtColor;
                const shirtY = this.state === 'small' ? 22 : 26;
                ctx.fillRect(this.x + 5, this.y + shirtY, 18, 10);

                // Overalls
                ctx.fillStyle = '#0066cc';
                ctx.fillRect(this.x + 8, this.y + shirtY + 2, 12, this.state === 'small' ? 8 : 16);

                // Buttons
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(this.x + 10, this.y + shirtY + 3, 2, 2);
                ctx.fillRect(this.x + 16, this.y + shirtY + 3, 2, 2);

                // Arms
                ctx.fillStyle = '#ffb380';
                const armY = this.state === 'small' ? 20 : 24;
                const armSwing = Math.sin(this.animFrame * Math.PI / 2) * 3;

                if (!this.skidding) {
                    ctx.fillRect(this.x + 2, this.y + armY + armSwing, 5, 12);
                    ctx.fillRect(this.x + 21, this.y + armY - armSwing, 5, 12);
                } else {
                    // Arms back when skidding
                    ctx.fillRect(this.x + (this.dir > 0 ? 22 : 1), this.y + armY - 5, 5, 10);
                }

                // Legs
                ctx.fillStyle = '#0066cc';
                const legY = this.state === 'small' ? 28 : 40;

                if (this.onGround && Math.abs(this.vx) > 0.5) {
                    const legSwing = Math.sin(this.animFrame * Math.PI) * 4;
                    ctx.fillRect(this.x + 8, this.y + legY + legSwing, 5, 16);
                    ctx.fillRect(this.x + 15, this.y + legY - legSwing, 5, 16);
                } else {
                    ctx.fillRect(this.x + 8, this.y + legY, 5, 16);
                    ctx.fillRect(this.x + 15, this.y + legY, 5, 16);
                }

                // Shoes
                ctx.fillStyle = '#654321';
                if (this.onGround) {
                    ctx.fillRect(this.x + 6, this.y + legY + 14, 7, 4);
                    ctx.fillRect(this.x + 15, this.y + legY + 14, 7, 4);
                }

                if (this.dead) {
                    ctx.restore();
                }

                ctx.restore();
            }

            powerUp() {
                if (this.state === 'small') {
                    this.state = 'big';
                    this.height = 48;
                    this.y -= 16;
                    playSound('powerup');
                    addScore(1000, this.x, this.y);
                } else if (this.state === 'big') {
                    this.state = 'fire';
                    playSound('powerup');
                    addScore(1000, this.x, this.y);
                    createParticles(this.x + this.width/2, this.y + this.height/2, 15, '#ff6600', 5);
                }
            }

            takeDamage() {
                if (this.invincible) return;

                if (this.state !== 'small') {
                    this.state = this.state === 'fire' ? 'big' : 'small';
                    if (this.state === 'small') {
                        this.height = 32;
                        this.y += 16;
                    }
                    this.invincible = true;
                    this.invincibleTimer = 120;
                    createParticles(this.x + this.width/2, this.y + this.height/2, 10, '#888', 4);
                } else {
                    this.die();
                }
            }

            die() {
                if (this.dead || this.invincible) return;
                this.dead = true;
                this.deathTimer = 0;
                this.vy = -12;
                playSound('death');
                game.state = 'dying';
            }

            respawn() {
                this.x = 100;
                this.y = 400;
                this.vx = 0;
                this.vy = 0;
                this.state = 'small';
                this.height = 32;
                this.dead = false;
                this.invincible = true;
                this.invincibleTimer = 180;
                game.state = 'playing';
                game.camera.x = 0;
            }

            showGameOver() {
                game.state = 'gameover';
                const overlay = document.getElementById('messageOverlay');
                overlay.className = 'message-overlay gameover show';
                document.getElementById('messageTitle').textContent = 'GAME OVER';
                document.getElementById('messageText').textContent = `Final Score: ${game.score.toString().padStart(6, '0')}`;
                document.getElementById('messageSubtext').textContent = 'Press R to Restart';
            }
        }

        // Block Class
        class Block {
            constructor(x, y, type, item = null) {
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 32;
                this.type = type; // ground, brick, question, pipe
                this.item = item;
                this.hit = false;
                this.bounceY = 0;
                this.bounceVel = 0;
                this.broken = false;
                this.animFrame = 0;
            }

            draw() {
                if (this.broken) return;

                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);
                ctx.translate(0, this.bounceY);

                switch(this.type) {
                    case 'ground':
                        // Detailed ground block
                        ctx.fillStyle = '#d2691e';
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.x + 2, this.y + 2, this.width - 4, this.height - 4);
                        ctx.fillStyle = '#a0522d';
                        ctx.fillRect(this.x + 4, this.y + 4, this.width - 8, this.height - 8);
                        // Grid pattern
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.width/2, this.y, this.width/2, this.height/2);
                        ctx.strokeRect(this.x, this.y + this.height/2, this.width/2, this.height/2);
                        break;

                    case 'brick':
                        ctx.fillStyle = '#cd853f';
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        ctx.fillStyle = '#8b4513';
                        // Brick rows
                        for (let row = 0; row < 4; row++) {
                            for (let col = 0; col < 2; col++) {
                                const bx = this.x + col * 16 + (row % 2) * 8;
                                const by = this.y + row * 8;
                                ctx.strokeStyle = '#654321';
                                ctx.strokeRect(bx, by, 16, 8);
                            }
                        }
                        break;

                    case 'question':
                        if (!this.hit) {
                            // Animated question block
                            const brightness = 200 + Math.sin(Date.now() * 0.01) * 55;
                            ctx.fillStyle = `rgb(${brightness}, ${brightness * 0.8}, 0)`;
                            ctx.fillRect(this.x, this.y, this.width, this.height);

                            ctx.fillStyle = '#ffa500';
                            ctx.fillRect(this.x + 3, this.y + 3, this.width - 6, this.height - 6);

                            // Question mark
                            ctx.fillStyle = '#000';
                            ctx.font = 'bold 24px monospace';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('?', this.x + 16, this.y + 18);

                            // Sparkle effect
                            const sparkle = Math.floor(Date.now() * 0.01) % 4;
                            ctx.fillStyle = '#fff';
                            if (sparkle === 0) ctx.fillRect(this.x + 2, this.y + 2, 3, 3);
                            if (sparkle === 1) ctx.fillRect(this.x + 27, this.y + 2, 3, 3);
                            if (sparkle === 2) ctx.fillRect(this.x + 27, this.y + 27, 3, 3);
                            if (sparkle === 3) ctx.fillRect(this.x + 2, this.y + 27, 3, 3);
                        } else {
                            // Used block
                            ctx.fillStyle = '#8b7355';
                            ctx.fillRect(this.x, this.y, this.width, this.height);
                            ctx.fillStyle = '#654321';
                            ctx.fillRect(this.x + 4, this.y + 4, this.width - 8, this.height - 8);
                        }
                        break;
                }

                ctx.restore();

                // Update bounce
                if (this.bounceY < 0) {
                    this.bounceVel += 0.8;
                    this.bounceY += this.bounceVel;
                    if (this.bounceY >= 0) {
                        this.bounceY = 0;
                        this.bounceVel = 0;
                    }
                }
            }

            onHit(fromBelow = false) {
                if (this.hit && this.type === 'question') return;

                // Break bricks if big Mario hits from below
                if (this.type === 'brick' && fromBelow && player.state !== 'small') {
                    this.broken = true;
                    playSound('breakblock');
                    addScore(50, this.x, this.y);
                    shakeCamera(8);

                    // Break particles
                    for (let i = 0; i < 4; i++) {
                        const px = this.x + (i % 2) * 16 + 8;
                        const py = this.y + Math.floor(i / 2) * 16 + 8;
                        game.particles.push({
                            x: px, y: py,
                            vx: ((i % 2) - 0.5) * 6,
                            vy: -8 - Math.random() * 4,
                            life: 60,
                            maxLife: 60,
                            color: '#cd853f',
                            size: 8,
                            gravity: true
                        });
                    }
                    return;
                }

                if (this.type === 'question' || this.type === 'brick') {
                    this.bounceY = -12;
                    this.bounceVel = 0;

                    if (this.item && !this.hit) {
                        this.spawnItem();
                        this.hit = true;
                    }

                    if (!this.item && this.type === 'brick') {
                        shakeCamera(3);
                    }
                }
            }

            spawnItem() {
                switch(this.item) {
                    case 'coin':
                        coins.push(new Coin(this.x, this.y - 32, true));
                        game.coins++;
                        game.score += 200;
                        playSound('coin');
                        addFloatingText(this.x + 16, this.y - 32, '200', '#ffd700');
                        break;
                    case 'mushroom':
                        powerups.push(new Powerup(this.x, this.y - 32, 'mushroom'));
                        break;
                    case 'fireflower':
                        powerups.push(new Powerup(this.x, this.y - 32, 'fireflower'));
                        break;
                    case '1up':
                        powerups.push(new Powerup(this.x, this.y - 32, '1up'));
                        break;
                }
            }
        }

        // Enemy Class
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 32;
                this.type = type; // goomba, koopa
                this.vx = -1.2;
                this.vy = 0;
                this.dead = false;
                this.squished = false;
                this.animFrame = 0;
                this.animTimer = 0;
                this.deathTimer = 0;
            }

            update() {
                if (this.squished) {
                    this.deathTimer++;
                    if (this.deathTimer > 30) this.dead = true;
                    return;
                }

                this.x += this.vx;
                this.vy += GRAVITY;
                this.y += this.vy;

                // Ground
                const groundY = 608 - this.height;
                if (this.y >= groundY) {
                    this.y = groundY;
                    this.vy = 0;
                }

                // Animation
                this.animTimer++;
                if (this.animTimer > 12) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 2;
                }

                // Block collision
                blocks.forEach(block => {
                    if (block.broken) return;
                    if (this.checkCollision(block)) {
                        if (this.x < block.x) {
                            this.x = block.x - this.width;
                            this.vx = -Math.abs(this.vx);
                        } else {
                            this.x = block.x + block.width;
                            this.vx = Math.abs(this.vx);
                        }
                    }
                });

                // Off screen
                if (this.x < game.camera.x - 100) this.dead = true;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                if (this.squished) {
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(this.x, this.y + 24, this.width, 8);
                    ctx.restore();
                    return;
                }

                if (this.type === 'goomba') {
                    // Body
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(this.x + 4, this.y + 10, 24, 22);

                    // Eyebrows
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x + 6, this.y + 10, 8, 3);
                    ctx.fillRect(this.x + 18, this.y + 10, 8, 3);

                    // Eyes
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x + 8, this.y + 14, 6, 8);
                    ctx.fillRect(this.x + 18, this.y + 14, 6, 8);

                    ctx.fillStyle = '#000';
                    const pupilX = this.x + (this.vx < 0 ? 9 : 11);
                    ctx.fillRect(pupilX, this.y + 17, 4, 4);
                    ctx.fillRect(pupilX + 10, this.y + 17, 4, 4);

                    // Frown
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x + 10, this.y + 24, 12, 3);

                    // Feet
                    ctx.fillStyle = '#654321';
                    const footOffset = this.animFrame * 4;
                    ctx.fillRect(this.x + footOffset, this.y + 30, 8, 4);
                    ctx.fillRect(this.x + 24 - footOffset, this.y + 30, 8, 4);

                } else if (this.type === 'koopa') {
                    // Shell
                    ctx.fillStyle = '#00aa00';
                    ctx.fillRect(this.x + 4, this.y + 14, 24, 18);

                    // Shell pattern
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(this.x + 8, this.y + 18, 16, 3);
                    ctx.fillRect(this.x + 10, this.y + 24, 12, 3);

                    // Head
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(this.x + 14, this.y + 6, 10, 12);

                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x + 16, this.y + 8, 2, 3);
                    ctx.fillRect(this.x + 20, this.y + 8, 2, 3);

                    // Beak
                    ctx.fillStyle = '#ff6600';
                    ctx.fillRect(this.x + (this.vx < 0 ? 12 : 24), this.y + 12, 3, 2);
                }

                ctx.restore();
            }

            checkCollision(obj) {
                return this.x < obj.x + obj.width &&
                       this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height &&
                       this.y + this.height > obj.y;
            }

            stomp() {
                this.squished = true;
                playSound('stomp');
                shakeCamera(4);

                game.combo++;
                game.comboTimer = 60;
                const points = 100 * game.combo;
                addScore(points, this.x, this.y);

                createParticles(this.x + 16, this.y + 16, 8, '#8b4513', 4);
            }

            hit() {
                this.dead = true;
                playSound('stomp');
                addScore(100, this.x, this.y);
                createParticles(this.x + 16, this.y + 16, 12, '#ff6600', 6);
            }
        }

        // Fireball Class
        class Fireball {
            constructor(x, y, dir) {
                this.x = x;
                this.y = y;
                this.width = 8;
                this.height = 8;
                this.vx = dir * FIREBALL_SPEED;
                this.vy = 0;
                this.bounces = 0;
                this.dead = false;
                this.animFrame = 0;
            }

            update() {
                this.x += this.vx;
                this.vy += GRAVITY;
                this.y += this.vy;

                // Ground bounce
                if (this.y > 600) {
                    this.y = 600;
                    this.vy = -8;
                    this.bounces++;
                    if (this.bounces > 3) this.dead = true;
                }

                // Block collision
                blocks.forEach(block => {
                    if (block.broken) return;
                    if (this.checkCollision(block)) {
                        this.dead = true;
                        createParticles(this.x, this.y, 5, '#ff6600', 3);
                    }
                });

                // Enemy collision
                enemies.forEach(enemy => {
                    if (enemy.dead) return;
                    if (this.checkCollision(enemy)) {
                        enemy.hit();
                        this.dead = true;
                    }
                });

                // Off screen
                if (this.x < game.camera.x - 50 || this.x > game.camera.x + canvas.width + 50) {
                    this.dead = true;
                }

                this.animFrame = (this.animFrame + 1) % 8;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                // Rotating fireball
                ctx.save();
                ctx.translate(this.x + 4, this.y + 4);
                ctx.rotate(this.animFrame * Math.PI / 4);

                ctx.fillStyle = '#ff6600';
                ctx.fillRect(-4, -4, 8, 8);
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(-3, -3, 6, 6);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-2, -2, 4, 4);

                ctx.restore();
                ctx.restore();
            }

            checkCollision(obj) {
                return this.x < obj.x + obj.width &&
                       this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height &&
                       this.y + this.height > obj.y;
            }
        }

        // Coin Class
        class Coin {
            constructor(x, y, animated = false) {
                this.x = x;
                this.y = y;
                this.startY = y;
                this.width = 24;
                this.height = 24;
                this.collected = false;
                this.animated = animated;
                this.animFrame = 0;
                this.floatVel = animated ? -6 : 0;
            }

            update() {
                if (this.animated) {
                    this.y += this.floatVel;
                    this.floatVel += 0.4;
                    if (this.y > this.startY - 60 && this.floatVel > 0) {
                        this.collected = true;
                    }
                }
                this.animFrame = (this.animFrame + 0.15) % 8;
            }

            draw() {
                if (this.collected) return;

                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                const scale = Math.abs(Math.cos(this.animFrame * Math.PI / 4));
                const w = 20 * scale;

                ctx.fillStyle = '#ffd700';
                ctx.fillRect(this.x + 12 - w/2, this.y + 2, w, 20);

                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(this.x + 12 - w/2 + 2, this.y + 4, Math.max(0, w - 4), 16);

                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x + 12 - w/2 + 3, this.y + 6, Math.max(0, w - 6), 12);

                ctx.restore();
            }

            collect() {
                this.collected = true;
                game.coins++;
                game.score += 200;
                playSound('coin');
                addFloatingText(this.x, this.y, '200', '#ffd700');
                createParticles(this.x + 12, this.y + 12, 6, '#ffd700', 3);

                // 1-up every 100 coins
                if (game.coins % 100 === 0) {
                    game.lives++;
                    addFloatingText(this.x, this.y - 30, '1-UP', '#00ff00');
                }
            }
        }

        // Powerup Class
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.startY = y;
                this.width = 28;
                this.height = 28;
                this.type = type; // mushroom, fireflower, 1up
                this.vx = 2;
                this.vy = 0;
                this.collected = false;
                this.emerging = true;
                this.emergeDistance = 0;
            }

            update() {
                if (this.emerging) {
                    this.y -= 0.5;
                    this.emergeDistance += 0.5;
                    if (this.emergeDistance >= 32) {
                        this.emerging = false;
                    }
                    return;
                }

                if (this.type !== 'fireflower') {
                    this.x += this.vx;
                    this.vy += GRAVITY;
                    this.y += this.vy;

                    // Ground
                    if (this.y > 580) {
                        this.y = 580;
                        this.vy = 0;
                    }

                    // Block collision
                    blocks.forEach(block => {
                        if (block.broken) return;
                        if (this.checkCollision(block)) {
                            if (this.x < block.x) {
                                this.x = block.x - this.width;
                                this.vx = -Math.abs(this.vx);
                            } else {
                                this.x = block.x + block.width;
                                this.vx = Math.abs(this.vx);
                            }
                        }
                    });
                }
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                if (this.type === 'mushroom' || this.type === '1up') {
                    const capColor = this.type === '1up' ? '#00ff00' : '#ff0000';

                    // Cap
                    ctx.fillStyle = capColor;
                    ctx.fillRect(this.x, this.y, 28, 16);

                    // Spots
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x + 4, this.y + 4, 7, 7);
                    ctx.fillRect(this.x + 17, this.y + 4, 7, 7);

                    // Stem
                    ctx.fillStyle = '#ffe4c4';
                    ctx.fillRect(this.x + 8, this.y + 12, 12, 16);

                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x + 10, this.y + 16, 2, 2);
                    ctx.fillRect(this.x + 16, this.y + 16, 2, 2);

                } else if (this.type === 'fireflower') {
                    // Stem
                    ctx.fillStyle = '#00aa00';
                    ctx.fillRect(this.x + 12, this.y + 14, 4, 14);

                    // Petals
                    const colors = ['#ff0000', '#ffaa00', '#ff6600', '#ffdd00'];
                    const time = Date.now() * 0.005;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI / 2) + time;
                        const px = this.x + 14 + Math.cos(angle) * 8;
                        const py = this.y + 8 + Math.sin(angle) * 8;
                        ctx.fillStyle = colors[i];
                        ctx.fillRect(px - 3, py - 3, 6, 6);
                    }

                    // Center
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(this.x + 11, this.y + 5, 6, 6);
                }

                ctx.restore();
            }

            checkCollision(obj) {
                return this.x < obj.x + obj.width &&
                       this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height &&
                       this.y + this.height > obj.y;
            }

            collect() {
                this.collected = true;

                if (this.type === '1up') {
                    game.lives++;
                    addFloatingText(this.x, this.y, '1-UP', '#00ff00');
                    playSound('powerup');
                } else {
                    player.powerUp();
                }
            }
        }

        // Pipe Class
        class Pipe {
            constructor(x, height) {
                this.x = x;
                this.y = 608 - height;
                this.width = 64;
                this.height = height;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                // Pipe body
                ctx.fillStyle = '#00aa00';
                ctx.fillRect(this.x + 4, this.y + 12, 56, this.height - 12);

                // Dark side
                ctx.fillStyle = '#008800';
                ctx.fillRect(this.x + 4, this.y + 12, 8, this.height - 12);
                ctx.fillRect(this.x + 52, this.y + 12, 8, this.height - 12);

                // Rim
                ctx.fillStyle = '#00cc00';
                ctx.fillRect(this.x, this.y, 64, 16);

                // Rim shadow
                ctx.fillStyle = '#008800';
                ctx.fillRect(this.x, this.y, 64, 4);

                // Rim highlight
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x + 4, this.y + 4, 56, 4);

                // Inner darkness
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 16, this.y + 8, 32, 8);

                ctx.restore();
            }
        }

        // Cloud Class
        class Cloud {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x * 0.4, 0);

                ctx.fillStyle = '#fff';
                const s = this.size;

                // Main cloud shape
                ctx.fillRect(this.x + s, this.y, s * 2.5, s * 1.2);
                ctx.fillRect(this.x + s * 0.5, this.y + s * 0.3, s * 3.5, s);
                ctx.fillRect(this.x, this.y + s * 0.6, s * 4.5, s * 0.8);

                // Puffs
                ctx.fillRect(this.x + s * 0.5, this.y + s * 0.2, s, s);
                ctx.fillRect(this.x + s * 2, this.y - s * 0.2, s * 1.2, s * 1.2);
                ctx.fillRect(this.x + s * 3.2, this.y + s * 0.1, s, s);

                ctx.restore();
            }
        }

        // Hill Class
        class Hill {
            constructor(x, size) {
                this.x = x;
                this.y = 608;
                this.size = size;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x * 0.6, 0);

                ctx.fillStyle = '#00cc44';

                // Hill shape (stacked rectangles to create curve)
                const steps = 8;
                for (let i = 0; i < steps; i++) {
                    const w = this.size * (1 - i / steps);
                    const h = this.size / steps;
                    ctx.fillRect(
                        this.x + this.size / 2 - w / 2,
                        this.y - (i + 1) * h,
                        w, h
                    );
                }

                ctx.restore();
            }
        }

        // Bush Class
        class Bush {
            constructor(x, size) {
                this.x = x;
                this.y = 608;
                this.size = size;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, 0);

                ctx.fillStyle = '#00aa00';
                const s = this.size;

                // Three puffs
                for (let i = 0; i < 3; i++) {
                    const px = this.x + i * s * 0.8;
                    const py = this.y - s + (i === 1 ? -s * 0.3 : 0);
                    ctx.fillRect(px, py, s, s);
                }

                ctx.restore();
            }
        }

        // Castle Class
        class Castle {
            constructor(x) {
                this.x = x;
                this.y = 380;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                // Main body
                ctx.fillStyle = '#a0a0a0';
                ctx.fillRect(this.x + 30, this.y + 80, 140, 148);

                // Towers
                ctx.fillRect(this.x, this.y + 100, 50, 128);
                ctx.fillRect(this.x + 150, this.y + 100, 50, 128);

                // Tower tops (crenellations)
                ctx.fillStyle = '#c0c0c0';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(this.x + i * 16, this.y + 100, 12, 16);
                    ctx.fillRect(this.x + 150 + i * 16, this.y + 100, 12, 16);
                }

                // Main castle top
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(this.x + 30 + i * 28, this.y + 80, 20, 16);
                }

                // Door
                ctx.fillStyle = '#2c1810';
                ctx.fillRect(this.x + 80, this.y + 170, 40, 58);

                // Door arch
                ctx.fillStyle = '#3d2817';
                ctx.fillRect(this.x + 85, this.y + 170, 30, 20);

                // Windows
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(this.x + 15, this.y + 130, 20, 25);
                ctx.fillRect(this.x + 165, this.y + 130, 20, 25);
                ctx.fillRect(this.x + 55, this.y + 110, 18, 22);
                ctx.fillRect(this.x + 127, this.y + 110, 18, 22);

                // Window crosses
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 24, this.y + 130, 2, 25);
                ctx.fillRect(this.x + 15, this.y + 142, 20, 2);
                ctx.fillRect(this.x + 174, this.y + 130, 2, 25);
                ctx.fillRect(this.x + 165, this.y + 142, 20, 2);

                // Flag pole
                ctx.fillStyle = '#654321';
                ctx.fillRect(this.x + 95, this.y, 4, 80);

                // Flag
                ctx.fillStyle = '#e30000';
                ctx.fillRect(this.x + 99, this.y + 10, 35, 25);

                // Flag star
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(this.x + 114, this.y + 20, 6, 6);

                ctx.restore();
            }
        }

        // Flag Pole Class
        class FlagPole {
            constructor(x) {
                this.x = x;
                this.y = 340;
                this.width = 12;
                this.height = 268;
                this.flagY = 0;
                this.flagSpeed = 0;
                this.triggered = false;
            }

            draw() {
                ctx.save();
                ctx.translate(-game.camera.x, -game.camera.y);

                // Pole
                ctx.fillStyle = '#e8e8e8';
                ctx.fillRect(this.x, this.y, 8, this.height);

                // Pole shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x, this.y, 3, this.height);

                // Flag
                ctx.fillStyle = '#00aa00';
                ctx.fillRect(this.x + 8, this.y + this.flagY, 40, 32);

                // Flag pattern
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + 16, this.y + this.flagY + 8, 8, 8);
                ctx.fillRect(this.x + 32, this.y + this.flagY + 16, 8, 8);

                // Top ornament
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(this.x - 4, this.y - 12, 16, 16);
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(this.x - 2, this.y - 10, 12, 12);

                ctx.restore();
            }

            update() {
                if (this.triggered && this.flagY < this.height - 40) {
                    this.flagSpeed += 0.3;
                    this.flagY += this.flagSpeed;
                    if (this.flagY >= this.height - 40) {
                        this.flagY = this.height - 40;
                        this.complete();
                    }
                }
            }

            trigger() {
                if (this.triggered) return;
                this.triggered = true;
                playSound('victory');

                const bonusPoints = Math.floor((this.height - (player.y - this.y)) / this.height * 5000);
                addScore(bonusPoints, this.x, player.y);

                game.state = 'victory';
                setTimeout(() => {
                    this.showVictory();
                }, 2000);
            }

            complete() {
                // Victory!
            }

            showVictory() {
                const overlay = document.getElementById('messageOverlay');
                overlay.className = 'message-overlay victory show';
                document.getElementById('messageTitle').textContent = 'VICTORY!';
                document.getElementById('messageText').textContent = `Score: ${game.score.toString().padStart(6, '0')}`;
                document.getElementById('messageSubtext').textContent = 'Press R to Play Again';
            }
        }

        // Game Objects
        let player;
        let blocks = [];
        let enemies = [];
        let coins = [];
        let powerups = [];
        let fireballs = [];
        let pipes = [];
        let clouds = [];
        let hills = [];
        let bushes = [];
        let castle;
        let flagPole;

        // Initialize Game
        function initGame() {
            player = new Player(100, 400);
            blocks = [];
            enemies = [];
            coins = [];
            powerups = [];
            fireballs = [];
            pipes = [];
            clouds = [];
            hills = [];
            bushes = [];

            // Ground
            for (let i = 0; i < 250; i++) {
                blocks.push(new Block(i * 32, 608, 'ground'));
            }

            // Clouds
            for (let i = 0; i < 25; i++) {
                clouds.push(new Cloud(
                    i * 350 + Math.random() * 100,
                    40 + Math.random() * 80,
                    25 + Math.random() * 15
                ));
            }

            // Hills
            for (let i = 0; i < 20; i++) {
                hills.push(new Hill(i * 450 + Math.random() * 100, 60 + Math.random() * 40));
            }

            // Bushes
            for (let i = 0; i < 40; i++) {
                bushes.push(new Bush(i * 200 + Math.random() * 80, 28 + Math.random() * 12));
            }

            // Level Design - A masterpiece!
            let x = 350;

            // === SECTION 1: Tutorial ===
            createQuestionBlock(x, 400, 'coin');
            createQuestionBlock(x + 64, 400, 'mushroom');
            createQuestionBlock(x + 128, 400, 'coin');
            x += 250;

            createBricks(x, 400, 5);
            createQuestionBlock(x + 96, 300, 'coin');
            x += 300;

            enemies.push(new Enemy(x, 400, 'goomba'));
            x += 100;
            enemies.push(new Enemy(x, 400, 'goomba'));
            x += 150;

            // === SECTION 2: First Pipe Area ===
            pipes.push(new Pipe(x, 64));
            x += 120;
            pipes.push(new Pipe(x, 96));
            x += 120;
            pipes.push(new Pipe(x, 128));
            x += 200;

            createFloatingPlatform(x, 350, 6);
            for (let i = 0; i < 6; i++) {
                coins.push(new Coin(x + i * 32 + 4, 300));
            }
            createQuestionBlock(x + 96, 250, 'fireflower');
            x += 300;

            // === SECTION 3: Enemy Gauntlet ===
            enemies.push(new Enemy(x, 400, 'goomba'));
            enemies.push(new Enemy(x + 80, 400, 'koopa'));
            enemies.push(new Enemy(x + 160, 400, 'goomba'));
            x += 280;

            createBricks(x, 400, 8);
            createQuestionBlock(x + 96, 400, 'coin');
            createQuestionBlock(x + 128, 300, '1up');
            createBricks(x + 160, 400, 3);
            x += 400;

            // === SECTION 4: Coin Heaven ===
            createStairs(x, 608, 6, true);
            x += 220;

            createFloatingPlatform(x, 300, 10);
            for (let i = 0; i < 15; i++) {
                coins.push(new Coin(x - 50 + i * 30, 200 + Math.sin(i * 0.5) * 40));
            }
            createQuestionBlock(x + 160, 200, 'coin');
            x += 400;

            createStairs(x, 608, 6, false);
            x += 250;

            // === SECTION 5: Pipe Maze ===
            pipes.push(new Pipe(x, 96));
            x += 100;
            enemies.push(new Enemy(x, 400, 'koopa'));
            x += 100;
            pipes.push(new Pipe(x, 128));
            x += 100;
            pipes.push(new Pipe(x, 96));
            x += 100;
            pipes.push(new Pipe(x, 160));
            x += 200;

            createQuestionBlock(x, 400, 'coin');
            createQuestionBlock(x + 32, 400, 'mushroom');
            createQuestionBlock(x + 64, 400, 'coin');
            x += 200;

            // === SECTION 6: Challenging Platforms ===
            for (let i = 0; i < 5; i++) {
                createFloatingPlatform(x + i * 130, 450 - i * 30, 3);
                enemies.push(new Enemy(x + i * 130 + 32, 380 - i * 30, i % 2 === 0 ? 'goomba' : 'koopa'));
            }
            x += 700;

            // === SECTION 7: Brick Heaven ===
            createBrickPyramid(x, 400, 7);
            createQuestionBlock(x + 96, 300, 'fireflower');
            x += 350;

            for (let i = 0; i < 12; i++) {
                coins.push(new Coin(x + i * 30, 350));
            }
            x += 400;

            // === SECTION 8: Mini Boss Area ===
            createFloatingPlatform(x, 450, 4);
            enemies.push(new Enemy(x + 32, 350, 'koopa'));
            x += 180;

            createFloatingPlatform(x, 400, 4);
            enemies.push(new Enemy(x + 32, 300, 'goomba'));
            enemies.push(new Enemy(x + 96, 300, 'goomba'));
            x += 180;

            createFloatingPlatform(x, 450, 4);
            enemies.push(new Enemy(x + 32, 350, 'koopa'));
            x += 250;

            // === SECTION 9: Grand Finale Approach ===
            pipes.push(new Pipe(x, 128));
            x += 150;

            createBricks(x, 400, 10);
            createQuestionBlock(x + 160, 300, 'coin');
            createQuestionBlock(x + 192, 300, '1up');
            createQuestionBlock(x + 224, 300, 'coin');
            x += 450;

            // Final coin collection
            for (let i = 0; i < 20; i++) {
                coins.push(new Coin(x + i * 28, 250 + Math.sin(i * 0.3) * 60));
            }
            x += 650;

            // Final enemies
            enemies.push(new Enemy(x, 400, 'koopa'));
            enemies.push(new Enemy(x + 100, 400, 'goomba'));
            enemies.push(new Enemy(x + 200, 400, 'koopa'));
            x += 400;

            // === SECTION 10: Castle ===
            createStairs(x, 608, 9, true);
            x += 350;

            flagPole = new FlagPole(x);
            x += 100;

            castle = new Castle(x);

            // Reset game state
            game.score = 0;
            game.coins = 0;
            game.lives = 3;
            game.time = 400;
            game.camera.x = 0;
            game.camera.y = 0;
            game.camera.shake = 0;
            game.particles = [];
            game.floatingTexts = [];
            game.combo = 0;
            game.comboTimer = 0;
        }

        // Level creation helpers
        function createQuestionBlock(x, y, item) {
            blocks.push(new Block(x, y, 'question', item));
        }

        function createBricks(x, y, count) {
            for (let i = 0; i < count; i++) {
                blocks.push(new Block(x + i * 32, y, 'brick'));
            }
        }

        function createFloatingPlatform(x, y, length) {
            for (let i = 0; i < length; i++) {
                blocks.push(new Block(x + i * 32, y, 'ground'));
            }
        }

        function createStairs(x, y, steps, ascending) {
            for (let i = 0; i < steps; i++) {
                const step = ascending ? i : steps - i - 1;
                for (let j = 0; j <= step; j++) {
                    blocks.push(new Block(x + i * 32, y - j * 32 - 32, 'ground'));
                }
            }
        }

        function createBrickPyramid(x, y, width) {
            for (let row = 0; row < width; row++) {
                const bricksInRow = width - row;
                for (let col = 0; col < bricksInRow; col++) {
                    blocks.push(new Block(
                        x + (row * 16) + col * 32,
                        y - row * 32,
                        'brick'
                    ));
                }
            }
        }

        // Collision Detection
        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        // Start Game
        function startGame() {
            document.getElementById('titleScreen').classList.add('hidden');
            document.getElementById('messageOverlay').classList.remove('show');
            game.state = 'playing';
            initGame();
            gameLoop();
        }

        // Update
        let timeCounter = 0;

        function update(deltaTime) {
            if (game.state !== 'playing' && game.state !== 'dying' && game.state !== 'victory') return;

            // Update player
            player.update();

            // Check block collisions
            blocks.forEach(block => {
                if (block.broken) return;

                if (checkCollision(player, block)) {
                    const overlapX = Math.min(
                        player.x + player.width - block.x,
                        block.x + block.width - player.x
                    );
                    const overlapY = Math.min(
                        player.y + player.height - block.y,
                        block.y + block.height - player.y
                    );

                    if (overlapX < overlapY) {
                        // Horizontal collision
                        if (player.x < block.x) {
                            player.x = block.x - player.width;
                        } else {
                            player.x = block.x + block.width;
                        }
                        player.vx = 0;
                    } else {
                        // Vertical collision
                        if (player.y < block.y) {
                            // Landing on top
                            player.y = block.y - player.height;
                            player.vy = 0;
                            player.onGround = true;
                            player.jumping = false;
                        } else {
                            // Hitting from below
                            player.y = block.y + block.height;
                            player.vy = 0;
                            block.onHit(true);
                        }
                    }
                }
            });

            // Update enemies
            enemies = enemies.filter(enemy => {
                enemy.update();

                if (!enemy.dead && checkCollision(player, enemy)) {
                    const stompThreshold = enemy.y + enemy.height * 0.4;
                    if (player.vy > 0 && player.y + player.height * 0.8 < stompThreshold) {
                        enemy.stomp();
                        player.vy = -10;
                        player.jumping = false;
                    } else {
                        player.takeDamage();
                    }
                }

                return !enemy.dead;
            });

            // Update coins
            coins = coins.filter(coin => {
                coin.update();

                if (!coin.collected && !coin.animated && checkCollision(player, coin)) {
                    coin.collect();
                }

                return !coin.collected;
            });

            // Update powerups
            powerups = powerups.filter(powerup => {
                powerup.update();

                if (!powerup.collected && checkCollision(player, powerup)) {
                    powerup.collect();
                }

                return !powerup.collected;
            });

            // Update fireballs
            fireballs = fireballs.filter(fireball => {
                fireball.update();
                return !fireball.dead;
            });

            // Update flag pole
            if (flagPole) {
                flagPole.update();

                if (!flagPole.triggered && checkCollision(player, flagPole)) {
                    flagPole.trigger();
                    player.vx = 0;
                }
            }

            // Update particles
            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.gravity !== false) p.vy += GRAVITY * 0.3;
                p.vx *= 0.98;
                p.life--;
                return p.life > 0;
            });

            // Update floating texts
            game.floatingTexts = game.floatingTexts.filter(t => {
                t.y += t.vy;
                t.life--;
                return t.life > 0;
            });

            // Update combo
            if (game.comboTimer > 0) {
                game.comboTimer--;
                if (game.comboTimer === 0) {
                    game.combo = 0;
                }
            }

            // Update timer
            if (game.state === 'playing') {
                timeCounter += deltaTime;
                if (timeCounter >= 1000) {
                    timeCounter = 0;
                    game.time--;
                    if (game.time <= 0) {
                        player.die();
                    }
                }
            }

            // Update HUD
            document.getElementById('score').textContent = game.score.toString().padStart(6, '0');
            document.getElementById('coins').textContent = '×' + game.coins.toString().padStart(2, '0');
            document.getElementById('time').textContent = game.time;
        }

        // Draw
        function draw() {
            // Sky
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#5c94fc');
            gradient.addColorStop(1, '#3a78dc');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Hills
            hills.forEach(hill => hill.draw());

            // Clouds
            clouds.forEach(cloud => cloud.draw());

            // Bushes
            bushes.forEach(bush => bush.draw());

            // Pipes
            pipes.forEach(pipe => pipe.draw());

            // Blocks
            blocks.forEach(block => block.draw());

            // Coins
            coins.forEach(coin => coin.draw());

            // Powerups
            powerups.forEach(powerup => powerup.draw());

            // Enemies
            enemies.forEach(enemy => enemy.draw());

            // Fireballs
            fireballs.forEach(fireball => fireball.draw());

            // Player
            if (player) player.draw();

            // Flag pole
            if (flagPole) flagPole.draw();

            // Castle
            if (castle) castle.draw();

            // Particles
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);
            game.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            });
            ctx.restore();

            // Floating texts
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            game.floatingTexts.forEach(t => {
                ctx.globalAlpha = t.life / 60;
                ctx.fillStyle = t.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(t.text, t.x, t.y);
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.restore();

            // Combo indicator
            if (game.combo > 1) {
                ctx.save();
                ctx.font = 'bold 24px monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ff6600';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.strokeText(`${game.combo}x COMBO!`, canvas.width / 2, 100);
                ctx.fillText(`${game.combo}x COMBO!`, canvas.width / 2, 100);
                ctx.restore();
            }
        }

        // Game Loop
        let lastTime = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Input
        document.addEventListener('keydown', e => {
            game.keys[e.key] = true;

            if ((e.key === 'r' || e.key === 'R') &&
                (game.state === 'gameover' || game.state === 'victory')) {
                game.state = 'playing';
                startGame();
            }

            if ([' ', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Shift'].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', e => {
            game.keys[e.key] = false;
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Initialize game objects on load to prevent errors
        blocks = [];
        enemies = [];
        coins = [];
        powerups = [];
        fireballs = [];
        pipes = [];
        clouds = [];
        hills = [];
        bushes = [];
    </script>
</body>
</html>